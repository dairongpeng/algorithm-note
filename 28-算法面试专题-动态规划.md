```Go
package main

import "math"

// 1-1ã€ğŸ’èƒŒåŒ…é—®é¢˜ï¼šç»™å®šä¸¤ä¸ªé•¿åº¦éƒ½ä¸ºNçš„æ•°ç»„weightså’Œvaluesï¼Œweight[i]å’Œvalues[i]åˆ†åˆ«ä»£è¡¨iå·ç‰©å“çš„é‡é‡å’Œä»·å€¼ã€‚
// ç»™å®šä¸€ä¸ªæ­£æ•°bagï¼Œè¡¨ç¤ºä¸€ä¸ªè½½é‡bagçš„è¢‹å­ï¼Œä½ è£…çš„ç‰©å“ä¸èƒ½è¶…è¿‡è¿™ä¸ªé‡é‡ã€‚è¿”å›ä½ èƒ½è£…ä¸‹æœ€å¤šçš„ä»·å€¼æ˜¯å¤šå°‘ï¼Ÿ
// w   é‡é‡æ•°ç»„
// v   ä»·å€¼æ•°ç»„
// bag èƒŒåŒ…çš„æœ€å¤§å®¹é‡
// è¿”å›è¯¥èƒŒåŒ…æ‰€èƒ½è£…ä¸‹çš„æœ€å¤§ä»·å€¼
func getMaxValue(w []int, v []int, bag int) int {
	// åˆå§‹ä¼ å…¥w,vã€‚indexä½ç½®å¼€å§‹ï¼ŒalreadyWè¡¨ç¤ºåœ¨indexä½ç½®çš„æ—¶å€™ï¼Œé‡é‡å·²ç»åˆ°è¾¾äº†å¤šå°‘
	return processBag(w, v, 0, 0, bag)
}

// é€’å½’çš„ç¬¬ä¸€ç§å°è¯•
// 0..index-1ä¸Šåšäº†è´§ç‰©çš„é€‰æ‹©ï¼Œä½¿å¾—ä½ å·²ç»è¾¾åˆ°çš„é‡é‡æ˜¯å¤šå°‘ alreadyW
// å¦‚æœè¿”å›-1ï¼Œè®¤ä¸ºæ²¡æœ‰æ–¹æ¡ˆ
// å¦‚æœä¸è¿”å›-1ï¼Œè®¤ä¸ºè¿”å›çš„å€¼æ˜¯çœŸå®ä»·å€¼
func processBag(w []int, v []int, index int, alreadyW int, bag int) int {
	// base case
	if alreadyW > bag {
		return -1
	}

	// é‡é‡æ²¡è¶…
	if index == len(w) {
		return 0
	}

	// å½“å‰ä¸é€‰æ‹©indexçš„è´§ç‰©æƒ…å†µä¸‹ï¼Œåç»­çš„ä»·å€¼
	// æ— éœ€ä¼ é€’å½“å‰indexçš„é‡é‡ï¼Œä¸”p1å°±æ˜¯æ€»ä»·å€¼
	p1 := processBag(w, v, index+1, alreadyW, bag)
	// å½“å‰é€‰æ‹©äº†indexçš„è´§ç‰©ï¼ŒæŠŠé‡é‡åŠ ä¸Šï¼Œç»§ç»­å‘ä¸‹é€’å½’
	p2next := processBag(w, v, index+1, alreadyW+w[index], bag)
	// p2è¡¨ç¤ºè¦äº†å½“å‰è´§ç‰©ä¹‹åæ€»ä»·å€¼åº”è¯¥æ˜¯åç»­ä»·å€¼åŠ ä¸Šå½“å‰ä»·å€¼
	p2 := -1
	if p2next != -1 {
		p2 = v[index] + p2next
	}

	return int(math.Max(float64(p1), float64(p2)))
}

// 1-2ã€èƒŒåŒ…é—®é¢˜çš„ç¬¬äºŒç§é€’å½’è§£æ³•ã€‚
func maxValue(w []int, v []int, bag int) int {
	// ç›¸æ¯”ä¸Šä¸€ä¸ªæš´åŠ›é€’å½’å°è¯•ï¼Œå»æ‰äº†alreadyWã€‚ç”¨èƒŒåŒ…å‰©ä½™ç©ºé—´ä»£æ›¿ï¼›restè¡¨ç¤ºèƒŒåŒ…å‰©ä½™ç©ºé—´ï¼Œåˆå§‹å‰©ä½™ç©ºé—´å°±æ˜¯èƒŒåŒ…å®¹é‡
	return processBag2(w, v, 0, bag)
}

func processBag2(w []int, v []int, index int, rest int) int {
	// base case 1 æ— æ•ˆæ–¹æ¡ˆã€‚èƒŒåŒ…å‰©ä½™å®¹é‡è£…ä¸ä¸‹å½“å‰é‡é‡çš„æƒ…å†µ
	if rest < 0 {
		return -1
	}

	// rest >=0ã€‚indexæ¥åˆ°ç»ˆæ­¢ä½ç½®ï¼Œæ²¡è´§ç‰©äº†ï¼Œå½“å‰è¿”å›0ä»·å€¼
	// base case 2
	if index == len(w) {
		return 0
	}

	// æœ‰è´§ä¹Ÿæœ‰ç©ºé—´ã€‚å½“å‰indexä¸é€‰æ‹©ï¼Œå¾—åˆ°p1æ€»ä»·å€¼
	p1 := processBag2(w, v, index+1, rest)
	p2 := -1
	// é€‰æ‹©äº†indexä½ç½®ï¼Œå‰©ä½™ç©ºé—´å‡å»å½“å‰é‡é‡
	p2Next := processBag2(w, v, index+1, rest-w[index])
	// é€‰æ‹©indexçš„æ€»ä»·å€¼ï¼Œæ˜¯index...çš„ä»·å€¼åŠ ä¸Šä¸ªå½“å‰indexçš„ä»·å€¼
	if p2Next != -1 {
		p2 = v[index] + p2Next
	}

	return int(math.Max(float64(p1), float64(p2)))
}

// 1-3ã€0-1èƒŒåŒ…é—®é¢˜ï¼šåŠ¨æ€è§„åˆ’è§£å†³æ–¹æ¡ˆã€‚åœ¨é€’å½’çš„æ€è·¯ä¸Šæ”¹è¿›
// ä»¥èƒŒåŒ…é—®é¢˜ä¸¾ä¾‹ï¼Œæˆ‘ä»¬æ¯ä¸€ä¸ªé‡é‡æœ‰è¦å’Œä¸è¦ä¸¤ä¸ªé€‰æ‹©ï¼Œä¸”éƒ½è¦é€’å½’å±•å¼€ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„é€’å½’æ—¶é—´å¤æ‚åº¦å°¾O(2^N)ã€‚
// è€Œè®°å¿†åŒ–æœç´¢ï¼Œæ ¹æ®å¯å˜å‚æ•°å¾—åˆ°çš„é•¿ä¸ºNä»·å€¼ä¸ºWçš„äºŒç»´è¡¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(N*bag)ã€‚
// å¦‚æœé€’å½’è¿‡ç¨‹ä¸­çŠ¶æ€è½¬ç§»æœ‰åŒ–ç®€ç»§ç»­ä¼˜åŒ–çš„å¯èƒ½ï¼Œä¾‹å¦‚æšä¸¾ã€‚é‚£ä¹ˆç»å…¸åŠ¨æ€è§„åˆ’å¯ä»¥ç»§ç»­ä¼˜åŒ–ï¼Œ
// å¦åˆ™è®°å¿†åŒ–æœç´¢å’ŒåŠ¨æ€è§„åˆ’çš„æ—¶é—´å¤æ‚åº¦æ˜¯ä¸€æ ·çš„
func dpWay(w []int, v []int, bag int) int {
	N := len(w)
	// å‡†å¤‡ä¸€å¼ dpè¡¨ï¼Œè¡Œå·ä¸ºæˆ‘ä»¬çš„é‡é‡èŒƒå›´bag+1ã€‚åˆ—ä¸ºæˆ‘ä»¬çš„ä»·å€¼æ•°ç›®ä¸ªæ•°çš„èŒƒå›´N+1ã€‚dpæ•°ç»„è£…ä¸‹æ‰€æœ‰çš„å¯èƒ½æ€§ã€‚
	dp := make([][]int, N+1)
	for i := 0; i < N+1; i++ {
		dp[i] = make([]int, bag+1)
	}

	// ç”±äºæš´åŠ›é€’å½’ä¸­index==w.lengthçš„æ—¶å€™ï¼Œæ€»æ˜¯è¿”å›0ã€‚æ‰€ä»¥ï¼š
	// dp[N][...] = 0ã€‚æ•´å½¢æ•°ç»„åˆå§‹åŒ–ä¸º0ï¼Œæ— éœ€å¤„ç†
	// ç”±äºNè¡Œå·²ç»åˆå§‹åŒ–ä¸º0ï¼Œæˆ‘ä»¬ä»N-1å¼€å§‹ã€‚å¡«æˆ‘ä»¬çš„dpè¡¨
	for index := N - 1; index >= 0; index-- {
		// å‰©ä½™ç©ºé—´ä»0å¼€å§‹ï¼Œä¸€ç›´å¡«å†™åˆ°bag
		for rest := 0; rest <= bag; rest++ {
			// é€šè¿‡æ­£å¸¸ä½ç½®çš„é€’å½’å¤„ç†ã€‚æˆ‘ä»¬è½¬è€Œå¡«å†™æˆ‘ä»¬çš„dpè¡¨
			// æ‰€ä»¥æˆ‘ä»¬p1ç­‰äºdpè¡¨çš„ä¸‹ä¸€å±‚å‘ä¸Šä¸€å±‚è¿”å›
			p1 := dp[index+1][rest]
			p2 := -1
			// rest - w[index] ä¸è¶Šç•Œ
			if rest-w[index] >= 0 {
				p2 = v[index] + dp[index+1][rest-w[index]]
			}
			// p1å’Œp2å–æœ€å¤§å€¼
			dp[index][rest] = int(math.Max(float64(p1), float64(p2)))
		}
	}
	// æœ€ç»ˆè¿”å›dpè¡¨çš„0ï¼Œbagä½ç½®ï¼Œå°±æ˜¯æˆ‘ä»¬æš´åŠ›é€’å½’çš„ä¸»å‡½æ•°è°ƒç”¨
	return dp[0][bag]
}

// 2ã€æœ€é•¿é€’å¢å­åºåˆ—é—®é¢˜
// é—®é¢˜æè¿°ï¼šç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚
// å­åºåˆ—æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåºã€‚ä¾‹å¦‚ï¼Œ[3,6,2,7] æ˜¯æ•°ç»„ [0,3,1,6,2,2,7] çš„å­åºåˆ—ã€‚
// ä¾‹å¦‚ï¼šnums = [10,9,2,5,3,7,101,18]ï¼Œ è¿”å›ç»“æœæ˜¯4ã€‚æœ€é•¿é€’å¢å­åºåˆ—æ˜¯ [2,3,7,101]ï¼Œå› æ­¤é•¿åº¦ä¸º 4 ã€‚
func lengthOfLIS(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	dp := make([]int, len(nums))

	dp[0] = 1
	// å…¨å±€æœ€å¤§
	max := 1

	for i := 1; i < len(nums); i++ {
		// é»˜è®¤æ¯ä¸ªå…ƒç´ çš„dp[i]éƒ½ä¸º1ï¼Œè¡¨ç¤ºè‡ªå·±å½¢æˆçš„é€’å¢å­åºåˆ—
		dp[i] = 1

		for j := 0; j < i; j++ {
			// å¦‚æœåœ¨å½“å‰ä½ç½®çš„å‰é¢ï¼Œå­˜åœ¨ä¸€ä¸ªæ¯”è‡ªå·±å°çš„å…ƒç´ ï¼Œè¯¥å…ƒç´ çš„dp[j]åŠ ä¸Šå½“å‰å…ƒç´ å½¢æˆçš„æ–°çš„dp[j] + 1æ¯”dp[i]å¤§ã€‚æ›´æ–°è¿™ä¸ªdp[i]ã€‚å¦åˆ™ä¸æ›´æ–°
			if nums[i] > nums[j] {
				dp[i] = int(math.Max(float64(dp[i]), float64(dp[j]+1)))
			}
		}

		// æœ€ä¸Šå±‚å¾ªç¯ï¼Œæ¯ä¸€è½®æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å…¨å±€max
		max = int(math.Max(float64(max), float64(dp[i])))
	}
	return max
}

// 3ã€æœ€å¤§è¿ç»­å­æ•°ç»„çš„å’Œï¼ˆæœ€å¤§å­åºå’Œï¼‰
// é—®é¢˜æè¿°ï¼šç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚
// ä¾‹å¦‚ï¼šnums = [-2,1,-3,4,-1,2,1,-5,4]ï¼Œè¿”å›6ã€‚è¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ï¼Œä¸º 6 ã€‚
func maxSubArray(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	N := len(nums)
	// dp[i] å«ä¹‰ï¼šå­æ•°ç»„å¿…é¡»ä»¥iç»“å°¾çš„æ—¶å€™ï¼Œæ‰€æœ‰å¯ä»¥å¾—åˆ°çš„å­æ•°ç»„ä¸­ï¼Œæœ€å¤§ç´¯åŠ å’Œæ˜¯å¤šå°‘ï¼Ÿ
	dp := make([]int, N)
	dp[0] = nums[0]
	// è®°å½•å…¨å±€æœ€å¤§çš„å­æ•°ç»„çš„å’Œ
	max := dp[0]
	for i := 1; i < N; i++ {
		// å½“å‰çš„å€¼
		p1 := nums[i]
		// å½“å‰çš„å€¼å’Œä¸Šä¸€ä¸ªä½ç½®çš„æœ€å¤§å’Œç´¯åŠ 
		p2 := nums[i] + dp[i - 1]
		// dp[i]ç­‰äºï¼Œå½“å‰çš„å€¼ï¼Œå’Œå½“å‰å€¼ä¸ä¸Šä¸€ä¸ªä½ç½®æœ€å¤§å’Œçš„ç´¯åŠ ï¼Œå–å¤§çš„
		dp[i] = int(math.Max(float64(p1), float64(p2)))
		// åˆ¤æ–­æ˜¯å¦è¦æ›´æ–°å…¨å±€æœ€å¤§å€¼
		max = int(math.Max(float64(max), float64(dp[i])))
	}
	// è¿”å›å…¨å±€æœ€å¤§å€¼
	return max
}

// 4ã€æ‰“å®¶åŠ«èˆé—®é¢˜
// é—®é¢˜æè¿°ï¼šä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚
// æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚
// ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚
// ç¤ºä¾‹è¾“å…¥ï¼š[1,2,3,1]ï¼Œ è¾“å‡º4ï¼›å·çªƒ 1 å·æˆ¿å±‹ (é‡‘é¢ = 1) ï¼Œç„¶åå·çªƒ 3 å·æˆ¿å±‹ (é‡‘é¢ = 3)ã€‚å·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ = 1 + 3 = 4 ã€‚
func rob(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	dp := make([]int, len(nums))

	for i := 0; i < len(nums); i++ {
		if i == 0 {
			dp[0] = nums[i]
		}
		if i == 1 {
			dp[1] = int(math.Max(float64(dp[0]), float64(nums[i])))
		}
		if i > 1 {
			dp[i] = int(math.Max(float64(dp[i - 1]), float64(dp[i - 2] + nums[i])))
		}
	}
	return dp[len(nums) - 1]
}

// 5ã€çˆ¬æ¥¼æ¢¯é—®é¢˜ã€‚
// å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚
// æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ
func climbStairs(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}

	dp := make([]int, n + 1)
	dp[1] = 1
	dp[2] = 2
	for i := 3; i <= n; i++ {
		dp[i] = dp[i - 1] + dp[i - 2]
	}
	return dp[n]
}

// 6ã€ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—é—®é¢˜
// ä¾‹å¦‚â€œab1cd2ef345ghâ€å’Œâ€œopq123rs4tx5yzâ€çš„æœ€é•¿å…¬å…±å­åºåˆ—ä¸ºâ€œ12345â€ã€‚å³åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€æœ‰ç›¸ç­‰çš„å­åºåˆ—é‡Œæœ€é•¿çš„ã€‚æ‰€ä»¥è¿”å›å­åºåˆ—çš„é•¿åº¦5
func lcse(str1 []byte, str2 []byte) int {
	if len(str1) == 0 {
		return 0
	}
	if len(str2) == 0 {
		return 0
	}

	dp := make([][]int, len(str1))
	for i := 0; i < len(str1); i++ {
		dp[i] = make([]int, len(str2))
	}
	if str1[0] == str2[0] {
		dp[0][0] = 1
	} else {
		dp[0][0] = 0
	}

	// å¡«ç¬¬0åˆ—çš„æ‰€æœ‰å€¼
	// ä¸€æ—¦st1rçš„iä½ç½®æŸä¸ªå­—ç¬¦ç­‰äºstr2çš„0ä½ç½®ï¼Œé‚£ä¹ˆä¹‹åéƒ½æ˜¯1
	for i := 1; i < len(str1); i++ {
		flag := -1
		if str1[i] == str2[0] {
			flag = 1
		} else {
			flag = 0
		}
		dp[i][0] = int(math.Max(float64(dp[i - 1][0]), float64(flag)))
	}

	// å¡«ç¬¬0è¡Œçš„æ‰€æœ‰å€¼
	// ä¸€æ—¦str2çš„jä½ç½®æŸä¸ªå­—ç¬¦ç­‰äºstr1çš„0ä½ç½®ï¼Œé‚£ä¹ˆä¹‹åéƒ½æ˜¯1
	for j := 1; j < len(str2); j++ {
		flag := -1
		if str1[0] == str2[j] {
			flag = 1
		} else {
			flag = 0
		}
		dp[0][j] = int(math.Max(float64(dp[0][j - 1]), float64(flag)))
	}

	for i := 1; i < len(str1); i++ {
		for j := 1; j < len(str2); j++ {
			// dp[i - 1][j]è¡¨ç¤ºå¯èƒ½æ€§2
			// dp[i][j - 1] è¡¨ç¤ºå¯èƒ½æ€§3
			dp[i][j] = int(math.Max(float64(dp[i - 1][j]), float64(dp[i][j - 1])))
			if str1[i] == str2[j] {
				dp[i][j] = int(math.Max(float64(dp[i][j]), float64(dp[i - 1][j - 1] + 1)))
			}
		}
	}
	return dp[len(str1) - 1][len(str2) - 1]
}
```

